{"ts":1376757191349,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"\n/*\n * routines for AES test page\n * extracted from rijndael.js -- Fritz Schneider's Rijndael Reference Implementation\n * http://www-cse.ucsd.edu/~fritz/rijndael.html\n * see below the original copyright notice\n */\n\n/* rijndael.js      Rijndael Reference Implementation\n   Copyright (c) 2001 Fritz Schneider\n \n This software is provided as-is, without express or implied warranty.  \n Permission to use, copy, modify, distribute or sell this software, with or\n without fee, for any purpose and by any individual or organization, is hereby\n granted, provided that the above copyright notice and this paragraph appear \n in all copies. Distribution as a part of an application or binary must\n include the above copyright notice in the documentation and/or other materials\n provided with the application or distribution.\n\n\n   As the above disclaimer notes, you are free to use this code however you\n   want. However, I would request that you send me an email \n   (fritz /at/ cs /dot/ ucsd /dot/ edu) to say hi if you find this code useful\n   or instructional. Seeing that people are using the code acts as \n   encouragement for me to continue development. If you *really* want to thank\n   me you can buy the book I wrote with Thomas Powell, _JavaScript:\n   _The_Complete_Reference_ :)\n\n   This code is an UNOPTIMIZED REFERENCE implementation of Rijndael. \n   If there is sufficient interest I can write an optimized (word-based, \n   table-driven) version, although you might want to consider using a \n   compiled language if speed is critical to your application. As it stands,\n   one run of the monte carlo test (10,000 encryptions) can take up to \n   several minutes, depending upon your processor. You shouldn't expect more\n   than a few kilobytes per second in throughput.\n\n   Also note that there is very little error checking in these functions. \n   Doing proper error checking is always a good idea, but the ideal \n   implementation (using the instanceof operator and exceptions) requires\n   IE5+/NS6+, and I've chosen to implement this code so that it is compatible\n   with IE4/NS4. \n\n   And finally, because JavaScript doesn't have an explicit byte/char data \n   type (although JavaScript 2.0 most likely will), when I refer to \"byte\" \n   in this code I generally mean \"32 bit integer with value in the interval \n   [0,255]\" which I treat as a byte.\n\n   See http://www-cse.ucsd.edu/~fritz/rijndael.html for more documentation\n   of the (very simple) API provided by this code.\n\n                                               Fritz Schneider\n                                               fritz at cs.ucsd.edu\n \n*/\n\n// This function takes an array of bytes (byteArray) and converts them\n// to a hexadecimal string. Array element 0 is found at the beginning of \n// the resulting string, high nibble first. Consecutive elements follow\n// similarly, for example [16, 255] --> \"10ff\". The function returns a \n// string.\n\nfunction byteArrayToHex(byteArray) {\n  var result = \"\";\n  if (!byteArray)\n    return;\n  for (var i=0; i<byteArray.length; i++)\n    result += ((byteArray[i]<16) ? \"0\" : \"\") + byteArray[i].toString(16);\n\n  return result;\n}\n\nfunction hex2s(hex)\n{\n  var r='';\n  if(hex.indexOf(\"0x\") == 0 || hex.indexOf(\"0X\") == 0) hex = hex.substr(2);\n\n  if(hex.length%2) hex+='0';\n\n  for(var i = 0; i<hex.length; i += 2)\n    r += String.fromCharCode(parseInt(hex.slice(i, i+2), 16));\n  return r;\n}\n\n// This function takes a prospective plaintext (string or array of bytes)\n// and pads it with zero bytes if its length is not a multiple of the block \n// size. If plaintext is a string, it is converted to an array of bytes\n// in the process. The type checking can be made much nicer using the \n// instanceof operator, but this operator is not available until IE5.0 so I \n// chose to use the heuristic below. \n\nfunction formatPlaintext(plaintext) {\n  var bpb = blockSizeInBits / 8;               // bytes per block\n  var i;\n\n  // if primitive string or String instance\n  if (typeof plaintext == \"string\" || plaintext.indexOf) {\n    plaintext = plaintext.split(\"\");\n    // Unicode issues here (ignoring high byte)\n    for (i=0; i<plaintext.length; i++)\n      plaintext[i] = plaintext[i].charCodeAt(0) & 0xFF;\n  } \n\n  for (i = bpb - (plaintext.length % bpb); i > 0 && i < bpb; i--) \n    plaintext[plaintext.length] = 0;\n  \n  return plaintext;\n}\n\n// Returns an array containing \"howMany\" random bytes. YOU SHOULD CHANGE THIS\n// TO RETURN HIGHER QUALITY RANDOM BYTES IF YOU ARE USING THIS FOR A \"REAL\"\n// APPLICATION.\n\nfunction getRandomBytes(howMany) {\n  var i;\n  var bytes = new Array();\n  for (i=0; i<howMany; i++)\n    bytes[i] = Math.round(Math.random()*255);\n  return bytes;\n}\n\n// rijndaelEncrypt(plaintext, key, mode)\n// Encrypts the plaintext using the given key and in the given mode. \n// The parameter \"plaintext\" can either be a string or an array of bytes. \n// The parameter \"key\" must be an array of key bytes. If you have a hex \n// string representing the key, invoke hexToByteArray() on it to convert it \n// to an array of bytes. The third parameter \"mode\" is a string indicating\n// the encryption mode to use, either \"ECB\" or \"CBC\". If the parameter is\n// omitted, ECB is assumed.\n// \n// An array of bytes representing the cihpertext is returned. To convert \n// this array to hex, invoke byteArrayToHex() on it. If you are using this \n// \"for real\" it is a good idea to change the function getRandomBytes() to \n// something that returns truly random bits.\n\nfunction rijndaelEncrypt(plaintext, key, mode) {\n  var i, aBlock;\n  var bpb = blockSizeInBits / 8;          // bytes per block\n  var ct;                                 // ciphertext\n\n  if (!plaintext || !key)\n    return;\n  if (key.length*8 != keySizeInBits)\n    return; \n  if (mode == \"CBC\")\n    ct = getRandomBytes(bpb);             // get IV\n  else {\n    mode = \"ECB\";\n    ct = new Array();\n  }\n\n  // convert plaintext to byte array and pad with zeros if necessary. \n  plaintext = formatPlaintext(plaintext);\n\n  var expandedKey = new keyExpansion(key);\n  \n  for (var block=0; block<plaintext.length / bpb; block++) {\n    aBlock = plaintext.slice(block*bpb, (block+1)*bpb);\n    if (mode == \"CBC\")\n      for (var i=0; i<bpb; i++) \n        aBlock[i] ^= ct[block*bpb + i];\n    ct = ct.concat(AESencrypt(aBlock, expandedKey));\n  }\n\n  return ct;\n}\n\n// rijndaelDecrypt(ciphertext, key, mode)\n// Decrypts the using the given key and mode. The parameter \"ciphertext\" \n// must be an array of bytes. The parameter \"key\" must be an array of key \n// bytes. If you have a hex string representing the ciphertext or key, \n// invoke hexToByteArray() on it to convert it to an array of bytes. The\n// parameter \"mode\" is a string, either \"CBC\" or \"ECB\".\n// \n// An array of bytes representing the plaintext is returned. To convert \n// this array to a hex string, invoke byteArrayToHex() on it. To convert it \n// to a string of characters, you can use byteArrayToString().\n\nfunction rijndaelDecrypt(ciphertext, key, mode) {\n  var bpb = blockSizeInBits / 8;          // bytes per block\n  var pt = new Array();                   // plaintext array\n  var aBlock;                             // a decrypted block\n  var block;                              // current block number\n\n  if (!ciphertext || !key) return;\n  if(typeof ciphertext == \"string\")\n  {\n    ciphertext = ciphertext.split(\"\");\n    for (i=0; i<ciphertext.length; i++)\n      ciphertext[i] = ciphertext[i].charCodeAt(0) & 0xFF;\n  }\n\n if (key.length*8 != keySizeInBits)\n    return; \n  if (!mode)\n    mode = \"ECB\";                         // assume ECB if mode omitted\n\n  var expandedKey = new prepare_decryption(key);\n \n  // work backwards to accomodate CBC mode \n  for (block=(ciphertext.length / bpb)-1; block>0; block--) {\n    aBlock = \n     AESdecrypt(ciphertext.slice(block*bpb,(block+1)*bpb), expandedKey);\n    if (mode == \"CBC\") \n      for (var i=0; i<bpb; i++) \n        pt[(block-1)*bpb + i] = aBlock[i] ^ ciphertext[(block-1)*bpb + i];\n    else \n      pt = aBlock.concat(pt);\n  }\n\n  // do last block if ECB (skips the IV in CBC)\n  if (mode == \"ECB\")\n    pt = AESdecrypt(ciphertext.slice(0, bpb), expandedKey).concat(pt);\n\n  return pt;\n}\n\n"]],"start1":0,"start2":0,"length1":0,"length2":8154}]],"length":8154}
